/*
 * Copyright 2020 Mooltiverse
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package configuration

import (
	"fmt" // https://pkg.go.dev/fmt
)

/*
Prints the command line help to the console
*/
func PrintHelp() {
	fmt.Println("Usage:")
	fmt.Println("    nyx [arguments] [command]")
	fmt.Println()
	fmt.Println("Commands are:")
	fmt.Println("    clean               reverts the repository to its initial state and removes files created by other commands, if any")
	fmt.Println("    infer               inspects the commit history and repository status and computes the project version")
	fmt.Println("    make                produces artifacts (i.e. changelog) as per the configuration")
	fmt.Println("    mark                commits, tags and pushes, according to the configuration and the repository status")
	fmt.Println("    publish             publish the new release, if any, to the configured services")
	fmt.Println()
	fmt.Println("Global arguments are:")
	fmt.Println("-b, --bump=<NAME>                      overrides the version component number to bump and prevents inference from the")
	fmt.Println("                                       commit history, causing the version component named <NAME> to always be bumped.")
	fmt.Println("                                       When using SEMVER <NAME> can be 'core', 'major', 'minor' or another name which")
	fmt.Println("                                       will be used as an additional identifier")
	fmt.Println("-c, --configuration-file=<PATH>        load the configuration file from the given <PATH> or remote URL. The file format")
	fmt.Println("                                       is inferred from the file extension. Supported formats are .json and .yml/.yaml.")
	fmt.Println("                                       When the extension is not recognized JSON will be used (default: .nyx.json or")
	fmt.Println("                                       .nyx.yaml or .nyx.yml)")
	fmt.Println("    --debug                            shorthand for --verbosity=DEBUG")
	fmt.Println("-d, --directory=<PATH>                 sets the working directory to a specific <PATH> (default: the current working")
	fmt.Println("                                       directory-)")
	fmt.Println("    --dry-run[=true|false]             when true no changes will be applied to the repository but only log messages are")
	fmt.Println("                                       displayed. When no value is passed then 'true' is assumed (default: false)")
	fmt.Println("    --error                            shorthand for --verbosity=ERROR")
	fmt.Println("    --fatal                            shorthand for --verbosity=FATAL")
	fmt.Println("    --help                             prints this help and exit")
	fmt.Println("    --info                             shorthand for --verbosity=INFO")
	fmt.Println("    --initial-version=<VERSION>        the default version to use when no previous version can be inferred from the")
	fmt.Println("                                       commit history (default: '0.1.0' when using SEMVER scheme)")
	fmt.Println("    --preset=<NAME>                    the name of a configuration preset to use. See the docs for available presets")
	fmt.Println("    --release-lenient[=true|false]     when true tags read from the commit history will tolerate (and ignore) arbitrary")
	fmt.Println("                                       prefixes. When no value is passed then 'true' is assumed (default: true)")
	fmt.Println("    --release-prefix=<PREFIX>          the prefix to add to newly generated releases (i.e. 'v' for 'v1.2.3')")
	fmt.Println("    --resume[=true|false]              resume operations from an existing state file. Requires --state-file. When no")
	fmt.Println("                                       value is passed then 'true' is assumed (default: false)")
	fmt.Println("    --scheme=<NAME>                    the version scheme to use. This version only supports SEMVER (default: SEMVER)")
	fmt.Println("    --shared-configuration-file=<PATH> load a shared configuration file from the given <PATH> or remote URL. The file")
	fmt.Println("                                       format is inferred from the file extension. Supported formats are .json and")
	fmt.Println("                                       .yml/.yaml. When the extension is not recognized JSON will be used")
	fmt.Println("                                       (default: .nyx-shared.json or .nyx-shared.yaml or .nyx-shared.yml)")
	fmt.Println("    --state-file=<PATH>                enables writing the state file to the given <PATH>. The file format is inferred")
	fmt.Println("                                       from the file extension. Supported formats are .json and .yml/.yaml. When the")
	fmt.Println("                                       extension is not recognized JSON will be used")
	fmt.Println("    --summary[=true|false]             prints a short summary containing relevant information from the internal state")
	fmt.Println("    --summary-file=<PATH>              saves a short summary containing relevant information from the internal state")
	fmt.Println("                                       to the given path")
	fmt.Println("    --trace                            shorthand for --verbosity=TRACE")
	fmt.Println("    --verbosity=<LEVEL>                controls the output verbosity, where <LEVEL> can be among FATAL, ERROR, WARNING,")
	fmt.Println("                                       INFO, DEBUG, TRACE (default: WARNING)")
	fmt.Println("-v, --version=<VERSION>                overrides the version and prevents version inference from the repository status")
	fmt.Println("                                       and commit history")
	fmt.Println("    --warning                          shorthand for --verbosity=WARNING")
	fmt.Println()
	fmt.Println("Changelog arguments are:")
	fmt.Println("    --changelog-path=<PATH>                           the absolute or relative <PATH> to the changelog file that is")
	fmt.Println("                                                      generated. If the file already exists it's overwritten.")
	fmt.Println("                                                      Setting this argument implicitly enables the changelog creation")
	fmt.Println("    --changelog-sections-<NAME>=<REGEX>               the definition of a section within a single release of the")
	fmt.Println("                                                      changelog, where <NAME> is the name of a section and <REGEX>")
	fmt.Println("                                                      is a regular expression that matches one or more commit types")
	fmt.Println("                                                      (as identified by the commit message convention)")
	fmt.Println("                                                      to appear below the section. See the docs for more")
	fmt.Println("    --changelog-substitutions-<REGEX>=<FORMAT_STRING> a replacement rule that uses the <REGEX> regular expressions")
	fmt.Println("                                                      to find strings within the rendered template and <FORMAT_STRING>")
	fmt.Println("                                                      to render the new content. See the docs for more. Multiple")
	fmt.Println("                                                      arguments like this can be passed for multiple substitutions")
	fmt.Println("    --changelog-template=<PATH>                       the absolute or relative <PATH> to a changelog template to use")
	fmt.Println("                                                      instead of the built-in template. The template must be a valid")
	fmt.Println("                                                      Handlebars template and can use functions. See the docs for the")
	fmt.Println("                                                      default template, the object model and the functions reference")
	fmt.Println()
	fmt.Println("Commit Message Conventions arguments are:")
	fmt.Println("    --commit-message-conventions-enabled=<NAMES>                             the comma separated list of convention")
	fmt.Println("                                                                             names enabled for the project. Each name")
	fmt.Println("                                                                             must correspond to a convention <NAME>.")
	fmt.Println("                                                                             Use this argument to toggle the configured")
	fmt.Println("                                                                             conventions on/off")
	fmt.Println("    --commit-message-conventions-<NAME>-expression=<REGEX>                   the regular expression that, when matches")
	fmt.Println("                                                                             a commit message, allows to associate the")
	fmt.Println("                                                                             commit with the convention named <NAME>")
	fmt.Println("                                                                             The configuration for a convention named")
	fmt.Println("                                                                             <NAME> is implicitly created by this option")
	fmt.Println("    --commit-message-conventions-<NAME>-bumpExpressions-<IDENTIFIER>=<REGEX> the association between the <IDENTIFIER> to")
	fmt.Println("                                                                             be bumped according to the convention named")
	fmt.Println("                                                                             <NAME> and the regular expression <REGEX>")
	fmt.Println("                                                                             that is evaluated against the commit")
	fmt.Println("                                                                             message to find a match. <REGEX> also")
	fmt.Println("                                                                             defines the commit type.")
	fmt.Println("                                                                             The configuration for a convention named")
	fmt.Println("                                                                             <NAME> is implicitly created by this option")
	fmt.Println()
	fmt.Println("Git arguments are:")
	fmt.Println("    --git-remotes-<NAME>-password=<TEMPLATE> sets the user name to use when connecting to the remote Git service named")
	fmt.Println("                                             <NAME>. When using OAuth or Personal Access Tokens you may need to pass")
	fmt.Println("                                             special values here (see the docs for details).")
	fmt.Println("                                             The configuration for git service named <NAME> is implicitly created by")
	fmt.Println("                                             this option")
	fmt.Println("    --git-remotes-<NAME>-user=<TEMPLATE>     sets the password to use when connecting to the remote Git service named")
	fmt.Println("                                             <NAME>. When using OAuth or Personal Access Tokens you may need to pass")
	fmt.Println("                                             special values here (see the docs for details).")
	fmt.Println("                                             The configuration for git service named <NAME> is implicitly created by")
	fmt.Println("                                             this option")
	fmt.Println()
	fmt.Println("Release Type arguments are:")
	fmt.Println("    --release-types-enabled=<NAMES>                                      the comma separated list of release type names")
	fmt.Println("                                                                         enabled for the project. Each name must")
	fmt.Println("                                                                         correspond to a release type <NAME> or the")
	fmt.Println("                                                                         built-in 'default' release type. Use this")
	fmt.Println("                                                                         argument to toggle the configured release")
	fmt.Println("                                                                         types on/off (default: ['default'])")
	fmt.Println("    --release-types-publication-services=<NAMES>                         the comma separated list of services to use to")
	fmt.Println("                                                                         publish artifacts when the release type has")
	fmt.Println("                                                                         the 'publish' flag enabled. Each name must")
	fmt.Println("                                                                         correspond to a service <NAME>. This option")
	fmt.Println("                                                                         applies to all release types")
	fmt.Println("    --release-types-remote-repositories=<NAMES>                          the comma separated list of remote repository")
	fmt.Println("                                                                         names to use when pushing changes, when the")
	fmt.Println("                                                                         release type has the 'push' flag enabled. Each")
	fmt.Println("                                                                         name must correspond to a git remote")
	fmt.Println("                                                                         repository named <NAME>. This option applies")
	fmt.Println("                                                                         to all release types")
	fmt.Println("    --release-types-<NAME>-collapse-versions=true|false                  determines if the release type uses collapsed")
	fmt.Println("                                                                         versioning (like a pre-release increment, see")
	fmt.Println("                                                                         the docs) or not. The configuration for a")
	fmt.Println("                                                                         release type named <NAME> is implicitly")
	fmt.Println("                                                                         created by this option (default: false)")
	fmt.Println("    --release-types-<NAME>-collapsed-version-qualifier=<TEMPLATE>        the extra qualifier used to bump version")
	fmt.Println("                                                                         numbers when using collapsed versioning.")
	fmt.Println("                                                                         This option is only considered when using")
	fmt.Println("                                                                         collapsed versioning. This value can be a")
	fmt.Println("                                                                         simple string or a template (see the docs)")
	fmt.Println("                                                                         that is evaluated dynamically at runtime.")
	fmt.Println("                                                                         The configuration for a release type named")
	fmt.Println("                                                                         <NAME> is implicitly created by this option")
	fmt.Println("    --release-types-<NAME>-description=<TEMPLATE>                        a string used as the description for new")
	fmt.Println("                                                                         releases. This value can be a simple string")
	fmt.Println("                                                                         or a template (see the docs) that is evaluated")
	fmt.Println("                                                                         dynamically at runtime. The configuration for")
	fmt.Println("                                                                         a release type named <NAME> is implicitly")
	fmt.Println("                                                                         created by this option")
	fmt.Println("                                                                         (default: 'Release {{version}}')")
	fmt.Println("    --release-types-<NAME>-filter-tags=<TEMPLATE>                        a regular expression that captures all the")
	fmt.Println("                                                                         tags in the commit history that are relevant")
	fmt.Println("                                                                         for versioning, while ignoring the others.")
	fmt.Println("                                                                         This value can be a simple string or a")
	fmt.Println("                                                                         template (see the docs) that is evaluated")
	fmt.Println("                                                                         dynamically at runtime. The configuration")
	fmt.Println("                                                                         for a release type named <NAME> is implicitly")
	fmt.Println("                                                                         created by this option")
	fmt.Println("    --release-types-<NAME>-git-commit=<TEMPLATE>                         a boolean that, when true, causes new commits")
	fmt.Println("                                                                         to be added to the repository if new artifacts")
	fmt.Println("                                                                         are produced. This value can be a simple")
	fmt.Println("                                                                         boolean or a template (see the docs) that is")
	fmt.Println("                                                                         evaluated dynamically at runtime. The")
	fmt.Println("                                                                         configuration for a release type named <NAME>")
	fmt.Println("                                                                         is implicitly created by this option")
	fmt.Println("                                                                         (default: false)")
	fmt.Println("    --release-types-<NAME>-git-commit-message=<TEMPLATE>                 the message that will be added when creating")
	fmt.Println("                                                                         commits, if any. This value can be a simple")
	fmt.Println("                                                                         string or a template (see the docs) that is")
	fmt.Println("                                                                         evaluated dynamically at runtime. The")
	fmt.Println("                                                                         configuration for a release type named")
	fmt.Println("                                                                         <NAME> is implicitly created by this option")
	fmt.Println("                                                                         (default: 'Release version {{version}}')")
	fmt.Println("    --release-types-<NAME>-git-push=<TEMPLATE>                           a boolean that, when true, causes repository")
	fmt.Println("                                                                         changes (if any) to be pushed to remote")
	fmt.Println("                                                                         repositories. This value can be a simple")
	fmt.Println("                                                                         boolean or a template (see the docs) that is")
	fmt.Println("                                                                         evaluated dynamically at runtime.")
	fmt.Println("                                                                         The configuration for a release type named")
	fmt.Println("                                                                         <NAME> is implicitly created by this option")
	fmt.Println("                                                                         (default: false)")
	fmt.Println("    --release-types-<NAME>-git-tag=<TEMPLATE>                            a boolean that, when true, causes new tags to")
	fmt.Println("                                                                         be added to the repository if new commits are")
	fmt.Println("                                                                         produced. This value can be a simple boolean")
	fmt.Println("                                                                         or a template (see the docs) that is")
	fmt.Println("                                                                         evaluated dynamically at runtime.")
	fmt.Println("                                                                         The configuration for a release type named")
	fmt.Println("                                                                         <NAME> is implicitly created by this option")
	fmt.Println("                                                                         (default: false)")
	fmt.Println("    --release-types-<NAME>-git-tag-message=<TEMPLATE>                    the message that will be added when creating")
	fmt.Println("                                                                         tags, if any. When setting this value")
	fmt.Println("                                                                         annotated tags will be created in place of")
	fmt.Println("                                                                         lightweight ones. This value can be a simple")
	fmt.Println("                                                                         string or a template (see the docs) that is")
	fmt.Println("                                                                         evaluated dynamically at runtime. The")
	fmt.Println("                                                                         configuration for a release type named")
	fmt.Println("                                                                         <NAME> is implicitly created by this option")
	fmt.Println("    --release-types-<NAME>-identifiers-<#>-position=PRE_RELEASE|BUILD    defines the position where the identifier will")
	fmt.Println("                                                                         appear in new versions (in the PRE_RELEASE or")
	fmt.Println("                                                                         the BUILD segment, see the docs for more). The")
	fmt.Println("                                                                         configuration for a release type named <NAME>")
	fmt.Println("                                                                         and an identifier with ordinal <#> is")
	fmt.Println("                                                                         implicitly created by this option")
	fmt.Println("                                                                         (default: BUILD)")
	fmt.Println("    --release-types-<NAME>-identifiers-<#>-qualifier=<TEMPLATE>          a string or template template (see the docs)")
	fmt.Println("                                                                         that is evaluated dynamically at runtime that")
	fmt.Println("                                                                         represents the leftmost part of an additional")
	fmt.Println("                                                                         identifier used in version. This must not be")
	fmt.Println("                                                                         empty. The configuration for a release type")
	fmt.Println("                                                                         named <NAME> and an identifier with ordinal")
	fmt.Println("                                                                         <#> is implicitly created by this option")
	fmt.Println("    --release-types-<NAME>-identifiers-<#>-value=<TEMPLATE>              a string or template template (see the docs)")
	fmt.Println("                                                                         that is evaluated dynamically at runtime that")
	fmt.Println("                                                                         represents the rightmost part of an additional")
	fmt.Println("                                                                         identifier used in version. If this is empty")
	fmt.Println("                                                                         then the leftmost part of the identified will")
	fmt.Println("                                                                         be used alone. The configuration for a release")
	fmt.Println("                                                                         type named <NAME> and an identifier with")
	fmt.Println("                                                                         ordinal <#> is implicitly created by")
	fmt.Println("                                                                         this option")
	fmt.Println("    --release-types-<NAME>-match-branches=<TEMPLATE>                     a regular expression that matches only the")
	fmt.Println("                                                                         branch names for which the release type is")
	fmt.Println("                                                                         configured and ignore the others. This value")
	fmt.Println("                                                                         can be a simple string or a template (see the")
	fmt.Println("                                                                         docs) that is evaluated dynamically at")
	fmt.Println("                                                                         runtime. The configuration for a release type")
	fmt.Println("                                                                         named <NAME> is implicitly created by")
	fmt.Println("                                                                         this option")
	fmt.Println("    --release-types-<NAME>-match-environment-variables-<VARNAME>=<VALUE> a rule that makes the release type effective")
	fmt.Println("                                                                         only when an environment variable named")
	fmt.Println("                                                                         <VARNAME> exists and has the same value as")
	fmt.Println("                                                                         <VALUE>. This argument can be repeated to set")
	fmt.Println("                                                                         multiple options for the given release type.")
	fmt.Println("    --release-types-<NAME>-match-workspace-status=CLEAN|DIRTY            a rule that makes the release type effective")
	fmt.Println("                                                                         only the git repository is in the given state")
	fmt.Println("                                                                         (CLEAN means there are no uncommitted changes,")
	fmt.Println("                                                                         DIRTY has uncommitted changes)")
	fmt.Println("    --release-types-<NAME>-publish=<TEMPLATE>                            a boolean that, when true, causes new")
	fmt.Println("                                                                         artifacts and new releases (if any) to be")
	fmt.Println("                                                                         published to the configured services. This")
	fmt.Println("                                                                         value can be a simple boolean or a template")
	fmt.Println("                                                                         (see the docs) that is evaluated dynamically")
	fmt.Println("                                                                         at runtime. The configuration for a release")
	fmt.Println("                                                                         type named <NAME> is implicitly created by")
	fmt.Println("                                                                         this option (default: false)")
	fmt.Println("    --release-types-<NAME>-version-range=<TEMPLATE>                      a regular expression that matches new version")
	fmt.Println("                                                                         numbers to be released for this release type.")
	fmt.Println("                                                                         When the expression doesn't match new version")
	fmt.Println("                                                                         numbers within the release type the process")
	fmt.Println("                                                                         stops with an error. This value can be a")
	fmt.Println("                                                                         simple string or a template (see the docs)")
	fmt.Println("                                                                         that is evaluated dynamically at runtime.")
	fmt.Println("                                                                         The configuration for a release type named")
	fmt.Println("                                                                         <NAME> is implicitly created by this option")
	fmt.Println("    --release-types-<NAME>-version-range-from-branch-name=true|false     a boolean that, when true, causes the version")
	fmt.Println("                                                                         range constraint to be inferred by the branch")
	fmt.Println("                                                                         name, assuming the branch name adheres to the")
	fmt.Println("                                                                         required naming convention. This value can be")
	fmt.Println("                                                                         a simple boolean or a template (see the docs)")
	fmt.Println("                                                                         that is evaluated dynamically at runtime.")
	fmt.Println("                                                                         The configuration for a release type named")
	fmt.Println("                                                                         <NAME> is implicitly created by this option")
	fmt.Println("                                                                         (default: false)")
	fmt.Println()
	fmt.Println("Services arguments are:")
	fmt.Println("    --services-<NAME>-type=<TYPE>                sets the <TYPE> for the service configuration named <NAME>. <NAME>")
	fmt.Println("                                                 can be any name assigned by the user and is a symbolic name for the")
	fmt.Println("                                                 service configuration. <TYPE> must be a supported service type")
	fmt.Println("                                                 (GITHUB or GITLAB). The configuration for a service named <NAME>")
	fmt.Println("                                                 is implicitly created by this option")
	fmt.Println("    --services-<NAME>-options-<OPTION>=<VALUE>   sets the option named <OPTION> to the given <VALUE> for the service")
	fmt.Println("                                                 named <NAME>. <NAME> can be any name assigned by the user and is a")
	fmt.Println("                                                 symbolic name for the service configuration. <OPTION> and <VALUE>")
	fmt.Println("                                                 depend on the service being configured and are listed in the")
	fmt.Println("                                                 documentation. This argument can be repeated to set multiple")
	fmt.Println("                                                 options for the given service. The configuration for a service")
	fmt.Println("                                                 named <NAME> is implicitly created by this option")
	fmt.Println()
	fmt.Println("Unrecognized arguments are ignored. For additional help see https://mooltiverse.github.io/nyx/.")
	fmt.Println()
}
