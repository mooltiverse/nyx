/*------------------------------------------------------------------------------
  Plugins DSL block
  https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block
------------------------------------------------------------------------------*/
plugins {
}

/*------------------------------------------------------------------------------
  Local sub-project properties
------------------------------------------------------------------------------*/
description = 'The Nyx Docker image'

// These statements force the other projects to be evaluated before this one. Without these,
// the ':modules:go:main:goBuild-nyx-linux-amd64' task would fail because its dependency ('goInit')
// would not be available yet.
// With these statements, instead, the project is entirely evaluated in advance, so we can use the
// ':modules:go:main:goBuild-nyx-linux-amd64' task outputs as it runs without errors.
project.evaluationDependsOn(":modules:go")
//project.evaluationDependsOn(":modules:go:main")

// The project version may have a '+' sign (when using extra identifier in the 'build' part)
// but since Docker doesn't handle it as a valid label we replace '+' with '_'.
def sanitizedVersion = rootProject.version.replaceAll('\\+','_')

// The directory used to build the Docker image
def dockerContextDir = file(buildDir.path+'/docker')

// The map of registries to publish the image to
// About DockerHub:
// - the repository 'mooltiverse/nyx' had to be created manually beforehand and permissions to write the repo had to be assigned to the service user.
// - images are published to: https://hub.docker.com/repository/docker/mooltiverse/nyx
// About GitHubContainerRegistry:
// - images are published to: https://github.com/orgs/mooltiverse/packages/container/package/nyx
def registries = [ 'DockerHub':"${nyxOrganizationID}/${rootProject.name}",
                   'GitHubContainerRegistry':"ghcr.io/${nyxOrganizationID}/${rootProject.name}" ]

// The list of labels to publish with. The 'latest' label is only added if we are publishing an official version (like x.y.z, without extra identifiers)
def labels = [ sanitizedVersion ]
if (java.util.regex.Pattern.matches("^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\$", rootProject.version)) {
    labels.add('latest')
}

/*------------------------------------------------------------------------------
  Additional tasks
------------------------------------------------------------------------------*/
task dockerContext(group: 'build', description: 'Builds the Docker context') {
    dependsOn tasks.getByPath(':modules:go:main:goBuild-nyx-linux-amd64')

    doLast {
        logger.info('Building the Docker context')
        mkdir dockerContextDir
        copy {
            // 
            from file('Dockerfile')
            into dockerContextDir
        }
        copy {
            // add the files built from ':modules:go:main:goBuild-nyx-linux-amd64' to the Docker build context so they are available for ADD and COPY directives
            // this also adds an implicit dependency to task ':modules:go:main:goBuild-nyx-linux-amd64'
            from tasks.getByPath(':modules:go:main:goBuild-nyx-linux-amd64').outputs
            into dockerContextDir
            include 'nyx-linux-amd64'
        }
    }
}

task dockerImage(group: 'build', description: 'Builds the Docker image') {
    dependsOn dockerContext

    doLast {
        logger.info('Building the Docker image')
        exec {
            workingDir = dockerContextDir
            logging.captureStandardOutput LogLevel.INFO
            logging.captureStandardError  LogLevel.ERROR
            // if this fails when using the Gradle wrapper you may need to run './gradlew --stop' first in order to get it running again
            commandLine 'docker', 'build', '--label', "version=$sanitizedVersion", '--tag', "${rootProject.name}:${sanitizedVersion}", '--rm', '.'
        }
    }
}

task dockerLogin(group: 'publishing', description: 'Logs in to remote Docker registries') {
    // Here we should iterate the registries map instead of using hardoded registries, but to do so we should also put credentials in the map
    doLast {
        // make sure we have the credentials to log in
        if ((findProperty("dockerHubUser") == null) || (findProperty("dockerHubToken") == null)) {
            throw new GradleException("The environment variable DOCKER_HUB_USERNAME or DOCKER_HUB_TOKEN is not defined so I can't log in to GitHub's Docker Container Registry to publish the new Docker image")
        }
        if ((findProperty("gitHubUser") == null) || (findProperty("gitHubToken") == null)) {
            throw new GradleException("The environment variable GITHUB_USERNAME or GITHUB_TOKEN is not defined so I can't log in to GitHub's Docker Container Registry to publish the new Docker image")
        }

        logger.info('Logging in Docker Hub')
        exec {
            logging.captureStandardOutput LogLevel.INFO
            logging.captureStandardError  LogLevel.ERROR
            // if this fails when using the Gradle wrapper you may need to run './gradlew --stop' first in order to get it running again
            // The 'dockerHubUser' and 'dockerHubToken' variables are passed as credentials fetching them in GitHub Actions as 'secrets.DOCKER_HUB_USERNAME' and 'secrets.DOCKER_HUB_TOKEN', respectively.
            // The actual environment variable names are 'ORG_GRADLE_PROJECT_dockerHubUser' and 'ORG_GRADLE_PROJECT_dockerHubToken'
            // See the GitHub Actions definition for more.
            if (System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')) {
                // Windows is used only on local development machines so there is no risk of exposing secrets from logs etc.
                // To make the 'stdin' method work on Windows we should also take care of when running on cmd or PowerShell, as they have different
                // means to echo environment variables. In short, it's not worth it and we just use the 'unsafe' method of passing the token as the '--password'
                commandLine 'docker', 'login', '--username', findProperty("dockerHubUser"), '--password', findProperty("dockerHubToken")
            } else {
                commandLine 'echo', '$ORG_GRADLE_PROJECT_dockerHubToken', '|', 'sudo', 'docker', 'login', '--username', findProperty("dockerHubUser"), '--password-stdin'
            }
        }

        logger.info('Logging in GitHub Container Registry')
        exec {
            logging.captureStandardOutput LogLevel.INFO
            logging.captureStandardError  LogLevel.ERROR
            // if this fails when using the Gradle wrapper you may need to run './gradlew --stop' first in order to get it running again
            // The 'gitHubUser' and 'gitHubToken' variables are passed as credentials fetching them in GitHub Actions as 'secrets.GITHUB_ACTOR' and 'secrets.GITHUB_TOKEN', respectively.
            // The actual environment variable names are 'ORG_GRADLE_PROJECT_gitHubUser' and 'ORG_GRADLE_PROJECT_gitHubToken'
            // See the GitHub Actions definition for more.
            if (System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')) {
                // Windows is used only on local development machines so there is no risk of exposing secrets from logs etc.
                // To make the 'stdin' method work on Windows we should also take care of when running on cmd or PowerShell, as they have different
                // means to echo environment variables. In short, it's not worth it and we just use the 'unsafe' method of passing the token as the '--password'
                commandLine 'docker', 'login', 'ghcr.io', '--username', findProperty("gitHubUser"), '--password', findProperty("gitHubToken")
            } else {
                commandLine 'echo', '$ORG_GRADLE_PROJECT_gitHubToken', '|', 'sudo', 'docker', 'login', 'ghcr.io', '--username', findProperty("gitHubUser"), '--password-stdin'
            }
        }
    }
}

// This is just a lifecycle task
task dockerTag(group: 'build', description: 'Tags the Docker image for the configured registries and labels') {
    // Dependencies are created along with dynamic tasks below

    // Only perform publishing if the Nyx release type enables publishing
// TODO: uncomment this
//    it.onlyIf { rootProject.nyxState.newRelease }
}

// This is just a lifecycle task
task dockerPush(group: 'publishing', description: 'Pushes the Docker image to the configured registries') {
    // Dependencies are created along with dynamic tasks below

    // Only perform publishing if the Nyx release type enables publishing
// TODO: uncomment this
//    it.onlyIf { rootProject.nyxState.newRelease }
}

// For each target registry and each label:
// - create a tag task
// - create a publish task
registries.each { registry ->
    labels.each { label ->
        // The tag tasks for the specific registry and label
        tasks.create(group: 'build', name: "dockerTag-${registry.key}-${label}", description: "Tags the Docker image for the ${registry.key} registry with the ${label} label") {
            // Task dependencies
            dependsOn dockerImage

            // Only perform publishing if the Nyx release type enables publishing
// TODO: uncomment this
//            it.onlyIf { rootProject.nyxState.newRelease }

            doLast {
                logger.info("Tagging the Docker image for the ${registry.key} registry with the ${label} label")
// TODO: remove these exec block
logger.quiet("Printing the Docker version")
exec {
logging.captureStandardOutput LogLevel.INFO
logging.captureStandardError  LogLevel.ERROR
    commandLine 'sudo', 'docker', '--version'
}
logger.quiet("Tagging Docker images")
                exec {
logging.captureStandardOutput LogLevel.INFO
logging.captureStandardError  LogLevel.ERROR
                    // if this fails when using the Gradle wrapper you may need to run './gradlew --stop' first in order to get it running again
                    if (System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')) {
                        commandLine 'docker', 'tag', "${rootProject.name}:${sanitizedVersion}", "${registry.value}:${label}"
                    } else {
                        commandLine 'sudo', 'docker', 'tag', "${rootProject.name}:${sanitizedVersion}", "${registry.value}:${label}"
                    }
                }
            }
        }
        tasks.create(group: 'publishing', name: "dockerPush-${registry.key}-${label}", description: "Pushes the Docker image to the ${registry.key} registry with the ${label} label") {
            // Task dependencies
            dependsOn dockerLogin

            // Only perform publishing if the Nyx release type enables publishing
            dependsOn tasks.named("dockerTag-${registry.key}-${label}")

// TODO: uncomment this
//            onlyIf { rootProject.nyxState.newRelease }

            doLast {
                logger.info("Pushing the Docker image to the ${registry.key} registry with the ${label} label")
// TODO: remove these exec block
logger.quiet("Printing the Docker version")
exec {
logging.captureStandardOutput LogLevel.INFO
logging.captureStandardError  LogLevel.ERROR
    commandLine 'sudo', 'docker', '--version'
}
logger.quiet("Pushing Docker images")
                exec {
logging.captureStandardOutput LogLevel.INFO
logging.captureStandardError  LogLevel.ERROR
                    // if this fails when using the Gradle wrapper you may need to run './gradlew --stop' first in order to get it running again
                    if (System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')) {
                        commandLine 'docker', 'push', "${registry.value}:${label}"
                    } else {
                        commandLine 'sudo', 'docker', 'push', "${registry.value}:${label}"
                    }
                }
            }
        }

        // Make the overall dockerTag lifecycle task depend on the platform specific tag task
        tasks.dockerTag.dependsOn tasks.named("dockerTag-${registry.key}-${label}")
        // Make the overall dockerPush lifecycle task depend on the platform specific tag task
        tasks.dockerPush.dependsOn tasks.named("dockerPush-${registry.key}-${label}")
    }
}

// This is just a lifecycle task
task publish(group: 'publishing', description: 'Publishes Docker images produced by this project') {
    dependsOn tasks.dockerPush
}

/*------------------------------------------------------------------------------
  Additional task dependencies
------------------------------------------------------------------------------*/
tasks.assemble.dependsOn tasks.dockerImage
tasks.build.dependsOn tasks.dockerImage
/*tasks.clean.dependsOn tasks.dockerClean*/
