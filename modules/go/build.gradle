/*------------------------------------------------------------------------------
  Plugins DSL block
  https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block
------------------------------------------------------------------------------*/
plugins {
}

/*------------------------------------------------------------------------------
  Local sub-project properties
------------------------------------------------------------------------------*/
description = 'All the Nyx Go artifacts'

/*------------------------------------------------------------------------------
  This is the configuration for this project and all sub-projects
------------------------------------------------------------------------------*/
allprojects {
}

/*------------------------------------------------------------------------------
  This is the configuration for all sub-projects, but not this project
------------------------------------------------------------------------------*/
subprojects {
    /*
     * Each sub project needs to define the 'modulePath' property with the module path like:
     *      ext { 
     *          modulePath = 'github.com/mooltiverse/nyx/modules/go/...'
     *      }
     */
    ext {
        // The module file
        modFile = file('go.mod')
    }

    task goClean(group: 'build', description: 'Cleans Go object files and cached files') {
        // Declare inputs and outputs of this task
        inputs.dir(projectDir)
        outputs.dir(projectDir)

        doLast {
            logger.info('Cleaning up Go artifacts')
            exec {
                standardOutput = new ByteArrayOutputStream()
                // if this fails when using the Gradle wrapper you may need to run './gradlew --stop' first in order to get it running again
                commandLine 'go', 'clean', '-r', '-cache', '-testcache', '-modcache'
                ext.output = { return standardOutput.toString() }
            }
        }
    }

    task goModInit(group: 'build', description: 'Initializes the go.mod file unless it aleady exists') {
        // Run this task only if the module file doesn't exist (which might also be ignored by .gitignore although it shouldn't)
        // Overwriting this file could be harmless as it could be generated again if it only contains dependencies that can be
        // automatically inferred from sources but it may cause a loss of information and break the project when it also has
        // extra directives like 'replace' (like in our case).
        onlyIf { !modFile.exists() }

        // Declare inputs and outputs of this task
        inputs.dir(projectDir)
        outputs.file(modFile)

        doLast {
            logger.info('Initializing the Go module '+modulePath+' file: '+modFile.path)
            exec {
                standardOutput = new ByteArrayOutputStream()
                // if this fails when using the Gradle wrapper you may need to run './gradlew --stop' first in order to get it running again
                commandLine 'go', 'mod', 'init', modulePath
                ext.output = { return standardOutput.toString() }
            }
        }
    }

    task goModUpdate(group: 'build', description: 'Updates the go.mod file by adding new dependencies or removing those unnecessary') {
        // Task dependencies
        dependsOn goModInit

        // Declare inputs and outputs of this task
        inputs.dir(projectDir)
        outputs.file(modFile)

        doLast {
            logger.info('Updating the Go module '+modulePath+' file: '+modFile.path)
            exec {
                standardOutput = new ByteArrayOutputStream()
                // if this fails when using the Gradle wrapper you may need to run './gradlew --stop' first in order to get it running again
                commandLine 'go', 'mod', 'tidy', '-v'
                ext.output = { return standardOutput.toString() }
            }
        }
    }

    task goInit(group: 'build', description: 'Initializes the module') {
        // Task dependencies
        dependsOn goModInit, goModUpdate

        // Declare inputs and outputs of this task
        outputs.dir(file(buildDir.path+'/bin'))

        doLast {
            mkdir file(buildDir.path+'/bin')
        }
    }

    task goBuild(group: 'build', description: 'Builds the Go binaries') {
        // Task dependencies
        dependsOn goInit

        // This is pretty much a lifecycle task that sub-projects need to add dependencies to
    }

    task goPublish(group: 'publishing', description: 'Lists the module to https://pkg.go.dev/') {
        // Task dependencies
        // nyxMark is required because the tag must already be available on GitHub when we run this task
        dependsOn goBuild, rootProject.tasks.nyxMark

        // The command only needs to run if a new release has been issued and already tagged by 'nyxMark'
        // otherwise the 'go list' commands fails because there is no such tagged version to read the go.mod file from
        onlyIf { rootProject.nyxState.newRelease }

        // See https://go.dev/doc/modules/publishing
        doLast {
            def modulereference = modulePath+'@'+version

            logger.info('Listing Go module '+modulereference+' to https://pkg.go.dev/')
            exec {
                //ignoreExitValue = true // TODO: remove this flag once the command is known to work
                environment 'GOPROXY', 'proxy.golang.org'
                workingDir = projectDir
                standardOutput = new ByteArrayOutputStream()
                // if this fails when using the Gradle wrapper you may need to run './gradlew --stop' first in order to get it running again
                commandLine 'go', 'list', '-m', modulereference
                ext.output = { return standardOutput.toString() }
            }
        }
    }

    /*------------------------------------------------------------------------------
      Additional task dependencies
    ------------------------------------------------------------------------------*/
    tasks.clean.dependsOn tasks.goClean
    tasks.assemble.dependsOn tasks.goBuild

    afterEvaluate {
        // Only perform publishing if the Nyx release type enables publishing
        // Remember that setting the 'onlyIf' on a task does not prevent its dependencies
        // to run so the tasks of the entire tree must be disabled
        // This is why we set the onlyIf to all tasks in the Publish group
        tasks.matching {
            it.group.equals('publishing')
        }.all {
            it.onlyIf { rootProject.nyxState.newRelease }
        }
    }
}

/*------------------------------------------------------------------------------
  Configurations
------------------------------------------------------------------------------*/
configurations {
}

/*------------------------------------------------------------------------------
  Repositories and dependencies
  https://docs.gradle.org/current/userguide/dependency_management_for_java_projects.html
*/
dependencies {
}

/*------------------------------------------------------------------------------
  Additional tasks
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
  Additional task dependencies
------------------------------------------------------------------------------*/
