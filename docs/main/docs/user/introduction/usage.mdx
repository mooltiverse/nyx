---
sidebar_position: 3
tags:
  - user
  - guide
  - usage
---

import {project} from '@site/src/data/projectVariables';

# Usage

## Available commands

Nyx provides the same features in all the available versions but the means to invoke each may change. This table summarizes the available commands and gives the available name for each when using different versions.

| Name                                        | Command Line Command                   | Gradle Task Name                       |
| ------------------------------------------- | -------------------------------------- | -------------------------------------- |
| Clean                                       | `clean`                                | [`nyxClean`](#nyxclean)                |
| Infer                                       | `infer`                                | [`nyxInfer`](#nyxinfer)                |
| Make                                        | `make`                                 | [`nyxMake`](#nyxmake)                  |
| Mark                                        | `mark`                                 | [`nyxMark`](#nyxmark)                  |
| Publish                                     | `publish`                              | [`nyxPublish`](#nyxpublish)            |

## Using the command line

### Download the binary

You can find the latest binaries for any platform in the [latest release](https://github.com/mooltiverse/nyx/releases/latest) assets.

Make sure you store the binary so that it's available from the `PATH` and it has execution permissions.

:::info
This guide assumes you rename the executable as `nyx`, regardless of the platform (or `nyx.exe` on Windows).
:::

This is all you need to use Nyx on the command line.

### Synopsis

Nyx comes with a whole lot of arguments that you can pass on the command line to let you control every single aspect of its behavior. You can see them all by running `nyx --help`, from which we have an abbreviated output here:

<pre>
  <code>
{`nyx --help

Nyx version: ${project.version}

Usage:
    nyx [arguments] [command]

Commands are:
    clean               reverts the repository to its initial state and removes files created by other commands, if any
    infer               inspects the commit history and repository status and computes the project version
    make                produces artifacts (i.e. changelog) as per the configuration
    mark                commits, tags and pushes, according to the configuration and the repository status
    publish             publish the new release, if any, to the configured services

Global arguments are:
    [...]

Changelog arguments are:
    [...]

Commit Message Conventions arguments are:
    [...]

Git arguments are:
    [...]

Git arguments are:
    [...]

Release Type arguments are:
    [...]

Services arguments are:
    [...]`}
  </code>
</pre>

As you can see you can give as much arguments as you like and one command at the end. Arguments start with a single (`-`) or double dash (`--`) and are detailed in the full output from `nyx --help` and in the [configuration reference](../configuration-reference/global-options.mdx#configuration-file).

The command needs to appear at the end of the command line with no dash sign. If you don't specify any command Nyx will run the default one `infer`. For an introduction on what every command does see [How Nyx Works](../introduction/how-nyx-works.mdx).

#### Dynamic argument names

One thing that is important to note is that many arguments names are dynamic and this may be confusing at first as it's different than common arguments on other tools. For example, the [`--services-<NAME>-type=<TYPE>`](../configuration-reference/services.mdx#type) argument has a dynamic `<NAME>` in the attribute name.

This is to allow users to define the `<TYPE>` value for arbitrary services whose name is dynamically configured. When passing this as an actual argument on the command line also the `<NAME>` part needs to be replaced so for example `--services-gh-type=GITHUB` sets the type `GITHUB` for a service instance configured under the name `gh`.

This kind of notation implies that the internal configuration model always creates a service configuration named `gh` whenever an argument like this is provided. This is somewhat different from configuration files where you need to create a `gh` section and then define additional options underneath.

:::info
Since argument names are dynamically defined Nyx will not complain in case of unsupported arguments.
:::

### Run the command

All you have to do is run the command according to the synopsis above. Remember to run Nyx from the Git project directory or pass the [`--directory`](../configuration-reference/global-options.mdx#directory) argument.

Also keep in mind that when no command is given on the command line [`infer`](../introduction/how-nyx-works.mdx#infer) is executed by default. This will generate and display the latest version for the project but will not change anything in the project directory. To run other commands you can specify them explicitly, as shown below.

### Configuration

You have different means to configure the tool. Whichever combination you use, see the [configuration reference](../configuration-reference/index.md) for a detailed description of each option.

In some cases you might prefer using command line arguments while in others configuration files (or even a combination of) might be the way you pick. In order to support some edge cases, all options can also be passed as environment variables.

Different configuration methods can be combined together with well known priorities of each means over the others so you have complete freedom to create configuration baselines and override values as you need. This might be especially useful for large organizations. See the [configuration methods](../introduction/configuration-methods.mdx) for more on this.

#### Using command line arguments

With the above said, you can start easy with:

```sh
nyx --preset=simple infer
```

This runs the *infer* command and uses the [*simple* preset](../configuration-presets/simple.mdx).

Keep in mind that while presets are a handy way to avoid repeating streamlined configurations, you don't need to use them and you can define your own from scratch by whatever configuration means.

#### Using configuration files

If you rather prefer to configure Nyx by means of configuration files you can use one of the [default configuration files](../introduction/configuration-methods.mdx#evaluation-order) that are looked up automatically or set the [`configurationFile`](../configuration-reference/global-options.mdx#configuration-file) global option to look for a file in a custom location.

Nonetheless, you can override configuration options from configuration files with command line arguments.

### The Nyx State

You can enable writing the Nyx [state](../state-reference/index.md) file by using the [`--state-file`](../configuration-reference/global-options.mdx#state-file) argument. You can have it in JSON or YAML, depending on the extension you set. Example:

```sh
nyx --state-file=nyx-state.json infer
```

After this command runs you can read the `nyx-state.json` file to inspect its contents and use them for other purposes. Check out the [State Reference](../state-reference/index.md) to know more about the contents and how powerful this can be.

### Exit codes

Nyx always returns 0 as the exit code unless some error occured, in which case 1 or other values other than 0 are returned.

## Using the Docker image

Many teams prefer using Docker containers for their CI/CD and local development environments. If that's your case you can use the Docker container that comes out of the box with Nyx.

The Docker images are published onto the two main registries:
* [Docker Hub](https://hub.docker.com/repository/docker/mooltiverse/nyx) (the default)
* [GitHub Container Registry](https://github.com/mooltiverse/nyx/pkgs/container/nyx)

Nyx' Docker image has a small footprint (less than 10Mb) and uses [Alpine Linux](https://www.alpinelinux.org/) as the base image.

:::info
All the examples in this page assume you're using the `latest` image pulling it from [Docker Hub](https://hub.docker.com/repository/docker/mooltiverse/nyx). They also assume you're making an ephemeral use of the container (you run it and dispose it every time). In case you need advanced use cases other than these please refer to the official [Docker Documentation](https://docs.docker.com/).
:::

### Requisites

All you need is a recent version of [Docker](https://www.docker.com/) installed and running.

### Pull the image

Let's start by pulling the image from the public registry. Open a shell and run:

```sh
$ docker pull mooltiverse/nyx:latest
latest: Pulling from mooltiverse/nyx
ab6db1bc80d0: Pull complete
[...]
Digest: sha256:976f4821d643e02fc55c884cd6c9af5e958011132145150b7dd97e01d71ba055
Status: Downloaded newer image for mooltiverse/latest
mooltiverse/latest
```

and make sure the new image is there:

```sh
$ docker image ls
REPOSITORY                                            TAG                 IMAGE ID       CREATED        SIZE
mooltiverse/nyx                                       latest              a14cbc284e81   2 days ago     7.35MB
```

### Run the container

To run the container you simply run a command like:

```sh
$ docker run -it --rm -v /local/path/to/project:/project mooltiverse/nyx:latest
```

A few things to note here:

1. there is no explicit command executed within the container because [`nyx infer`](../introduction/how-nyx-works.mdx#infer) is executed by default. This will generate and display the latest version for the project but will not change anything in the project directory. To run other commands you can specify them explicitly, as shown below
2. a local folder (`/local/path/to/project`) is mounted from the host into the container at the default location `/project`. You need to change `/local/path/to/project` to whatever path is hosting your Git repository, or mount a Docker volume hosting the Git repository in case you already have one (in this case, pass your volume name to the command line like `docker run -it --rm -v project-volume:/project mooltiverse/nyx:latest [...]`, where `project-volume` has to be changed to your volume name)
3. Nyx is using the default configuration means ([configuration files](../introduction/configuration-methods.mdx#supported-file-grammars) available in the project directory at standard locations)

:::info
When running on Linux or Mac hosts you may also want to map the host user ID to the container user in order to avoid issue with file permissions. You can do this by adding this option to the command line: `-u $(id -u):$(id -g)`. See the [Docker run reference](https://docs.docker.com/engine/reference/run/) for more.
:::

#### Running specific commands

In order to run a specific command you need to pass it on the command line, like:

```sh
$ docker run -it --rm -v /local/path/to/project:/project mooltiverse/nyx:latest <COMMAND>
```

So if you need to run the [publish](../introduction/how-nyx-works.mdx#publish) command, run the container as:

```sh
$ docker run -it --rm -v /local/path/to/project:/project mooltiverse/nyx:latest publish
```

#### Mounting the project volume or folder

You can pass Nyx your project folder as a path on the host or as a Docker volume. What you need to do is:

* replace `/local/path/to/project` with an actual host path when the project directory is shared from the Docker host to the container, or
* replace `/local/path/to/project` with a Docker volume name when the project directory is already in a Docker volume

For more on volumes and mounts please see [the official Docker documentation](https://docs.docker.com/storage/volumes/).

#### Passing the configuration to Nyx

Generally speaking, configuring Nyx within a container is just like using it from the [command line](#using-the-command-line). This means that if [configuration files](../introduction/configuration-methods.mdx#supported-file-grammars) are available in the project directory at their default locations they will be loaded as usual and if additional options are passed on the [command line](../introduction/configuration-methods.mdx#command-line-options) they will be used.

The one caveat abous passing configuration as [environment variables](../introduction/configuration-methods.mdx#environment-variables) in a Docker container is about setting those variables by means of one or more `-e` [flags](https://docs.docker.com/engine/reference/run/#env-environment-variables).

## Using the Gradle plugin

When using Gradle, the native Nyx plugin is the easiest and most effective way of using Nyx. The plugin can be used with the Groovy or the Kotlin syntax, although this documentation always refers to Groovy unless otherwise specified.

:::info
All the examples in this page assume you're using the plain `gradle` command. If you're using the (recommended) [wrapper](https://docs.gradle.org/current/userguide/gradle_wrapper.html) just change instances of the `gradle` command with `./gradlew`.
:::

:::info
Some extra information on the Gradle Plugin internals is available [here](../in-depth/gradle-plugin.mdx).
:::

### Apply the plugin

You can apply the [plugin](https://plugins.gradle.org/plugin/com.mooltiverse.oss.nyx) as a *project plugin* or as a *settings plugin*. You're suggested to use the *settings plugin* to make sure you have properties are evaluated early in the build lifecycle as detailed in [this post](../../resources/troubleshooting/the-gradle-version-project-property-is-unspecified.mdx).

When using Groovy you can use the same [plugin DSL](https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block) in both cases:

<pre>
  <code>
{`plugins {
    id "com.mooltiverse.oss.nyx" version "${project.version}"
}`}
  </code>
</pre>

Add the above definition to the `settings.gradle` file to deploy the plugin as a *settings plugin* (suggested) or to the `build.gradle` file to deploy the plugin as a *project plugin*.

If you're using Kotlin you can use this example for your `build.gradle.kts` or `settings.gradle.kts` when applying the *project plugin* or *settings plugin*, respectively:

<pre>
  <code>
{`plugins {
    id("com.mooltiverse.oss.nyx") version "${project.version}"
}`}
  </code>
</pre>

### Configure the plugin

You have different means to configure the plugin and in these sections we'll introduce you to all of them. Whichever combination of configuration means you use, see the [configuration reference](../configuration-reference/index.md) for a detailed description of each option.

:::warning
The [`version`](../configuration-reference/global-options.mdx#version) configuration option is not handled like other options because it would overlap [Gradle's standard `version` project property](https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:standard_project_properties). The plugin reads and writes the standard Gradle option to provide a consistent behavior and reduce impact on existing build scripts. See [here](../configuration-reference/global-options.mdx#the-version-in-gradle-scripts) for more.
:::

You can also mix different configuration means according to the [configuration evaluation order](../introduction/configuration-methods.mdx#evaluation-order) in order to use what better suits your needs. Mixed configurations are often used to reuse some parts or entire configurations across projects and organizations or to override some inherited values on a project basis.

Examples of different configuration files are available [here](../../resources/examples/index.md).

#### Using the extension

The easier way to configure Nyx is via a Gradle *extension*.

When using Groovy the extension is a configuration block named `nyx` you add inside your `settings.gradle` or `build.gradle` script (depending on where and how you applied the plugin, as a *settings plugin* or *project plugin*, respectively), like this:

<pre>
  <code>
{`plugins {
    id "com.mooltiverse.oss.nyx" version "${project.version}"
}

nyx {
    // a few examples
    dryRun = false
    resume = false
    stateFile = '.nyx-state.yml'
    verbosity = "INFO"
}`}
  </code>
</pre>

The *configuration block* shown above is where you can place configuration options defined in the [configuration reference](../configuration-reference/index.md) using the [Gradle](../introduction/configuration-methods.mdx#gradle) syntax.

When using Kotlin you still have a configuration block very similar to the one above but with some differences.

Configuring the *project plugin* using Kotlin you add something like this to your `build.gradle.kts`:

<pre>
  <code>
{`plugins {
    id("com.mooltiverse.oss.nyx") version "${project.version}"
}

nyx {
    // a few examples
    dryRun.set(false)
    resume.set(false)
    stateFile.set(".nyx-state.yml")
    verbosity.set("DEBUG")
}`}
  </code>
</pre>

As you can see Kotlin uses a different way to set values. If, instead, you're configuring the *settings plugin* in Kotlin your `settings.gradle.kts` file looks like:

<pre>
  <code>
{`plugins {
    id("com.mooltiverse.oss.nyx") version "${project.version}"
}

configure<com.mooltiverse.oss.nyx.gradle.NyxExtension> {
    // a few examples
    dryRun.set(false)
    resume.set(false)
    stateFile.set(".nyx-state.yml")
    verbosity.set("DEBUG")
}`}
  </code>
</pre>

So, when using Kotlin, the difference between configuring the *project plugin* or *settings plugin* is in the way the configuration block starts.

#### Using configuration files

If you rather prefer to configure Nyx by means of configuration files you can use one of the [default configuration files](../introduction/configuration-methods.mdx#evaluation-order) that are looked up automatically or set the [`configurationFile`](../configuration-reference/global-options.mdx#configuration-file) global option to look for a file in a custom location.

#### Multi-project builds

If you have a [multi-project build](https://docs.gradle.org/current/userguide/multi_project_builds.html) and apply the plugin in the `settings.gradle` file you can only apply it to the root project as that's how Gradle restricts the `settings.gradle`. On the other hand, if you use the `settings.gradle`, the Nyx plugin should be applied to the root project only as it's supposed to be where the Git repository is located.

:::warning
Nyx makes no hard checks whether it's applied to the root project or a subproject so if you know what you're doing you can apply the plugin to one of the subprojects as well.
:::

To use the project version from subprojects you should use the `rootProject.version` property instead of the simple `version` or `project.version` or you may get the undesired *unspecified* value in place of the expected version.

If using the *project plugin*, in order to be sure the version has been set before you use it, add a dependency from the task you read the `rootProject.version` to the [`nyxInfer`](#nyxinfer) task in the root project, like:

```groovy
tasks.register('myTask')  {
  dependsOn ':nyxInfer'
  doLast {
    println rootProject.version
  }
}
```

or

```groovy
tasks.myTask.dependsOn rootProject.tasks.nyxInfer
```

This dependency is not needed when using the *settings plugin*.

You may also propagate the root project version to all sub projects if that's what you need, and to do so you can add the following block in the root project build script:

```groovy
subprojects {
  version = rootProject.version
}
```

### Core tasks

Once the plugin is applied the following tasks and [dependencies](https://docs.gradle.org/current/userguide/tutorial_using_tasks.html#sec:task_dependencies) are available. All tasks belong to the `Release` group.

#### `nyxClean`

Runs the `clean` command.

This task has no efferent dependecies but if the `clean` lifecycle task is defined (like when using the [Base](https://docs.gradle.org/current/userguide/base_plugin.html) plugin) it is attached with a dependency on this task.

#### `nyxInfer`

Runs the `infer` command.

This task has no efferent dependecies while [`nyxMake`](#nyxmake) depends on on this task.

When the plugin is [applied](#apply-the-plugin) as a *settings plugin* you don't need to run this task explicitly as it's implicitly executed in the [initialization](https://docs.gradle.org/current/userguide/build_lifecycle.html) phase.

Otherwise, when the plugin is applied as a *project plugin*, since this is the task that actually makes available all the information required for a new release (including the [Gradle's `version` property](https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:standard_project_properties)), you should make all tasks that need that information [dependent](https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:adding_dependencies_to_tasks) on this, directly or indirectly.

For example:

```groovy
tasks.myTask.dependsOn rootProject.tasks.nyxInfer
```

or 

```groovy
tasks.register('myTask')  {
  dependsOn ':nyxInfer'
  doLast {
    ...
  }
}
```

:::info
See [this post](../../resources/troubleshooting/the-gradle-version-project-property-is-unspecified.mdx) for more on the early inference of the `version` and other properties.
:::

#### `nyxMake`

Runs the `make` command.

This task depends on the [`nyxInfer`](#nyxinfer) task while [`nyxMark`](#nyxmark) depends on on this task. Moreover, if an `assemble` lifecycle tasks is defined (like when using the [Base](https://docs.gradle.org/current/userguide/base_plugin.html) plugin) it is attached with a dependency on this task.

#### `nyxMark`

Runs the `mark` command.

This task depends on the [`nyxMake`](#nyxmake) task while [`nyxPublish`](#nyxpublish) depends on on this task.

#### `nyxPublish`

Runs the `publish` command.

This task depends on the [`nyxMark`](#nyxmark) task while the [`release`](#release) task is attached to depend on this task.

### Lifecycle tasks

The following additional [lifecycle tasks](https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:lifecycle_tasks) are added for convenience.

#### `release`

The `release` lifecycle task is created if there is no task with the same name already defined. This task provides no actions by itself but is just meant to let you run `gradle release` to run the entire release process.

The newly created or existing `release` task is attached to depend on the [`nyxPublish`](#nyxpublish) task.

### Accessing the Nyx State extra project property from build scripts

Another nifty feature that may save you a bunch of coding is accessing the [Nyx State](../state-reference/index.md) from within a Gradle script.

The entire State is bound to the project *extra properties* with the `nyxState` property name so, starting from that, you can read any property exported by Nyx.

:::info
The `nyxState` property is only available after at least one [core task](#core-tasks) has executed. When using the [settings plugin](#apply-the-plugin) this is not an issue as the tasks run automatically in the early phases. Not all State properties are available at the same type (after the same task execution), please check out the [reference](../state-reference/index.md) for each property to know when it's available.
:::

This way you can have all the Nyx properties handy without even [storing the State file](../configuration-reference/global-options.mdx#state-file) on disk. For example, to only run a task if the [release scope](../state-reference/release-scope.mdx) contains [significant changes](../state-reference/release-scope.mdx#significant-commits) you can check the `project.nyxState.releaseScope.significantCommits` list property while to reuse the same timestamp used by Nyx you can read the [`project.nyxState.significant`](../state-reference/global-attributes.mdx#timestamp).

Example:

```groovy
task dumpSomeDiagnostics() {
  dependsOn nyxInfer
  doLast {
    println project.nyxState.bump
    println project.nyxState.directory.getAbsolutePath()
    println project.nyxState.scheme.toString()
    println Long.valueOf(project.nyxState.timestamp).toString()
    println project.nyxState.version
  }
}
```

In this example `dumpSomeDiagnostics` represents some arbitrary task that depends on [`nyxInfer`](#nyxinfer) just to make sure the `nyxState` is available and is used to print a few attributes from the state.

## Using the GitHub Action

:::tip
Check out [this section](../quick-start/docker-container.mdx) for a quick introduction on the GitHub Action.
:::

To use the GitHub Ation just configure it as a job in your workflow, like:

```yaml
jobs:
  infer-version:
    name: Infer the repository version with Nyx
    runs-on: ubuntu-latest
    steps:
    - name: Git checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
    // highlight-start
    - name: Nyx infer
      id: nyx
      uses: mooltiverse/nyx@main
    // highlight-end
    - name: Print version # This step uses the version inferred by Nyx
      run: echo the inferred version is ${{ steps.nyx.outputs.version }}
```

Nyx supports a [variety of configuration means](../introduction/configuration-methods.mdx), including configuration files, command line arguments and environment variables. All configurable options are accessible via any of the supported configuration methods. The [configuration reference](../configuration-reference/index.md) gives you full details on each option.

Using the GitHub Action you can use:

* [configuration files](../introduction/configuration-methods.mdx#supported-file-grammars) (using JSON or YAML grammars, putting them in their default paths or using custom ones)
* [environment variables](../introduction/configuration-methods.mdx#environment-variables), which is the suggested way for passing [secrets](https://docs.github.com/en/actions/security-guides/encrypted-secrets), using the [`env`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsenv) block in [workflow files](https://docs.github.com/en/actions/using-workflows/about-workflows) (i.e. passing the [`GITHUB_TOKEN`](../configuration-reference/services.mdx#github-configuration-options))
* action inputs, using the [`with`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepswith) block in [workflow files](https://docs.github.com/en/actions/using-workflows/about-workflows)

:::info
When using the GitHub Action, action inputs replace [command line options](../introduction/configuration-methods.mdx#command-line-options), which are not available with Actions. Action inputs are a subset of all the available command line arguments and this is due to Actions not supporting options with dynamic names. Nonetheless they give you a handy way to set the most common settings. For all those arguments not available as inputs you can still use configuration files or environment variables. Action inputs will be passed to Nyx as [command line arguments](../introduction/configuration-methods.mdx#command-line-options) under the hood so they have priority over all other configuration means.
:::

See below for a full reference.

### Inputs

| Name                                                      | Notes |
| --------------------------------------------------------- | ----- |
| `command` | Selects which [Nyx command](../introduction/how-nyx-works.mdx) to run. Allowed values are: `clean`, `infer` (default), `make`, `mark`, `publish`. When selecting `infer` Nyx will only read the repository and give you back the inferred `version`. `make` will build the changelog, `mark` will apply tags, make commits and push changes to the remote repository. `publish` will publish the release to the configured services |
| [`bump`](../configuration-reference/global-options.mdx#bump) | Instructs Nyx on which identifier to bump on the past version in order to build the new `version`. This option prevents Nyx to [infer](../introduction/how-nyx-works.mdx#infer) the identifier to bump from the commit history. |
| [`changelogPath`](../configuration-reference/changelog.mdx#path) | The absolute or relative path to a local file where the changelog is saved when generated. If a file already exists at the given location it is overwritten. Setting this value also enables the changelog creation, which is to say, when this option is not defined no changelog is generated. A common value used for this option is `CHANGELOG.md` |
| [`changelogTemplate`](../configuration-reference/changelog.mdx#template) | The absolute or relative path to a local file to use as a template instead of the Nyx built-in. The file must contain a valid [Handlebars](https://handlebarsjs.com/) template ([Mustache](https://mustache.github.io/) templates are also supported). Template [functions](../configuration-reference/templates.mdx#functions) can be used in custom templates |
| [`commitMessageConventionsEnabled`](../configuration-reference/commit-message-conventions.mdx#enabled) | The comma separated list of commit message convention names that are enabled for the project. Here you can enable or disable the various conventions, either custom or default. The list of [available conventions](../configuration-reference/commit-message-conventions.mdx) is defined by the configured `preset` or a [configuration file](../introduction/configuration-methods.mdx#evaluation-order) |
| [`configurationFile`](../configuration-reference/global-options.mdx#configuration-file) | This option allows you to load a configuration file from a location other than default ones. This can be a relative (to the Action's working directory) path to a local file or an URL to load a remote file. This configuration file can override other options, as per the [evaluation order](../introduction/configuration-methods.mdx#evaluation-order), and can be authored as `.yaml` (or `.yml`) or `.json` (the format is inferred by the file extension or JSON is used by default) just like the default configuration files |
| [`directory`](../configuration-reference/global-options.mdx#directory) | Sets the working directory for Nyx. The directory is where Nyx searches for the Git repository and is also used as the base path when relative paths to local files or directories. By default Nyx uses the Action's working directory for this. Paths defined here must be relative to the Action's working directory |
| [`dryRun`](../configuration-reference/global-options.mdx#dry-run) | When this flag is set to `true` no action altering the repository state, either local or remote, is taken. Instead the actions that would be taken if this flag was not set are printed to the log |
| [`initialVersion`](../configuration-reference/global-options.mdx#initial-version) | The default version to use when no previous version can be [inferred](../introduction/how-nyx-works.mdx#infer) from the commit history (i.e. when the repository has no tagged releases yet) |
| [`preset`](../configuration-reference/global-options.mdx#preset) | This option allows you to import one [preset configuration](../configuration-presets/index.md) into your configuration to save configuration time and effort |
| [`releaseLenient`](../configuration-reference/global-options.mdx#release-lenient) | When this option is enabled (it is by default), Nyx will attempt to tolerate prefixes and other unnecessary characters (like leading zeroes) when **reading** Git tags from the commit history. When `true`, tags like `vx.y.x`, `relx.y.x` etc will be detected as release tags (for version `x.y.x`), regardless of the prefix Nyx uses to generate release names |
| [`releasePrefix`](../configuration-reference/global-options.mdx#release-prefix) | It’s a common practice to add a leading string to version numbers to give releases a name. Common prefixes are v or rel but you might use anything, or no prefix at all |
| [`releaseTypesEnabled`](../configuration-reference/release-types.mdx#enabled) | The comma separated list of release types that are enabled for the project. Here you can enable or disable the various release types, either custom or default. The list of [available release types](../configuration-reference/release-types.mdx) is defined by the configured `preset` or a [configuration file](../introduction/configuration-methods.mdx#evaluation-order) |
| [`releaseTypesPublicationServices`](../configuration-reference/release-types.mdx#publication-services) | The comma separated list of service configuration names to be used to publish releases when the matched release type has the [`publish`](../configuration-reference/release-types.mdx#publish) flag enabled. The list of [available services](../configuration-reference/services.mdx) is defined by the configured `preset` or a [configuration file](../introduction/configuration-methods.mdx#evaluation-order) |
| [`releaseTypesRemoteRepositories`](../configuration-reference/release-types.mdx#remote-repositories) | The comma separated list of remote repository names to be used to push changes to when the matched release type has the [`gitPush`](../configuration-reference/release-types.mdx#git-push) flag enabled. The list of [available remote repositories](../configuration-reference/git.mdx#remotes) is defined by the configured `preset` or a [configuration file](../introduction/configuration-methods.mdx#evaluation-order) |
| [`resume`](../configuration-reference/global-options.mdx#resume) | When this flag is set to `true` Nyx tries to load an existing [state file](../configuration-reference/global-options.mdx#state-file) and resume operations from where it left when the state file was saved |
| [`scheme`](../configuration-reference/global-options.mdx#scheme) | Selects the [version scheme](../introduction/version-schemes.mdx) to use. Defaults to [SEMVER](../introduction/version-schemes.mdx#semantic-versioning-semver) |
| [`sharedConfigurationFile`](../configuration-reference/global-options.mdx#shared-configuration-file) | This option allows you to load a shared configuration file from a location other than [default ones](../introduction/configuration-methods.mdx#evaluation-order) |
| [`stateFile`](../configuration-reference/global-options.mdx#state-file) | Enables the creation of the [state file](../state-reference/index.md) where Nyx stores its findings and generated values |
| [`summaryFile`](../configuration-reference/global-options.mdx#summary-file) | Enables the creation of the summary file where Nyx saves a subset of relevant information from the internal state as name value pairs, easy to parse |
| [`verbosity`](../configuration-reference/global-options.mdx#verbosity) | Controls the amount of output emitted by Nyx, where values are: `FATAL`, `ERROR`, `WARNING`, `INFO`, `DEBUG`, `TRACE` |
| [`version`](../configuration-reference/global-options.mdx#version) | Overrides the version and prevents Nyx to [infer](../introduction/how-nyx-works.mdx#infer). When overriding this value you take over the tool and go the manual versioning way so Nyx won’t try to read past versions from the commit history nor determine which identifiers to bump |

### Outputs

| Name                                                      | Notes |
| --------------------------------------------------------- | ----- |
| [`branch`](../state-reference/global-attributes.mdx) | This string contains the current Git branch name |
| [`bump`](../state-reference/global-attributes.mdx#bump) | This string contains the name of the identifier that has been bumped to create the new `version`. Version identifiers depend on the selected version `scheme` |
| [`coreVersion`](../state-reference/global-attributes.mdx#core-version) | This value is `true` when the `version` only uses *core* identifiers (i.e. is not a pre-release) according to the `scheme` |
| [`latestVersion`](../state-reference/global-attributes.mdx#latest-version) | This value is `true` when the `version` is the latest in the repository, meaning that, according to the `scheme`, there are no other tags in the Git repository representing any version greater than `version` |
| [`newRelease`](../state-reference/global-attributes.mdx#new-release) | This value is `true` when the `newVersion` is `true` and a new release with the current `version` has to be [issued](../configuration-reference/release-types.mdx#publish) |
| [`newVersion`](../state-reference/global-attributes.mdx#new-version) | This value is `true` when the `version` is new and is basically a shorthand to testing if `version` is different than the `previousVersion` |
| [`scheme`](../state-reference/global-attributes.mdx#scheme) | The configured [version `scheme`](../introduction/version-schemes.mdx) |
| [`timestamp`](../state-reference/global-attributes.mdx#timestamp) | The timestamp in the Unix format (seconds since Jan 01 1970. (UTC). Example: `1591802533` |
| [`previousVersion`](../state-reference/release-scope.mdx#previous-version) | The version that was released before the one being created |
| [`primeVersion`](../state-reference/release-scope.mdx#prime-version) | The version that is used as the baseline when bumping version numbers when the release type uses [collapsed versioning](../configuration-reference/release-types.mdx#collapse-versions) (the *pre-release* versioning) |
| [`version`](../state-reference/global-attributes.mdx#version) | The version that was [inferred](../introduction/how-nyx-works.mdx#infer), unless the [`version`](../configuration-reference/global-options.mdx#version) configuration option was passed to override inference. When the version is not overridden or inferred the [`initialVersion`](../configuration-reference/global-options.mdx#initial-version) is used |

All the above outputs are also contained in the [state file](../state-reference/index.md) (if enabled using the [`stateFile`](../configuration-reference/global-options.mdx#state-file) option) or the summary file (if enabled using the [`summaryFile`](../configuration-reference/global-options.mdx#summary-file) option).

### Limitations

This is a [Docker Action](https://docs.github.com/en/actions/creating-actions/about-custom-actions#types-of-actions) so it's only available for Linux runners.

### Versioning

Although you can use a specific [version](https://github.com/mooltiverse/nyx/tags) for this action you are recommended to always use the latest version from the `main` branch (`uses: mooltiverse/nyx@main`).

This action always uses the latest Nyx version.

### Caveats

#### Git repository checkout action

Your pipelines on GitHub Actions probably start with the [checkout action](https://github.com/actions/checkout), which, by default, only checks out the latest commit as the fetch-depth parameter defaults to 1.

This prevents Nyx from inferring information from the commit history and you likely end up with the inferred version to always be the initial version (i.e. 0.1.0) as further illustrated here.

To work around this you just have to configure the checkout action to always fetch the entire commit history by setting the `fetch-depth` parameter to `0` as in this example:

```yaml
- uses: actions/checkout@v3
  with:
    // highlight-start
    fetch-depth: 0
    // highlight-end
```

#### Combined release process

Just like for other means of using Nyx, in order to [separate Nyx actions and run other jobs or steps in between](../introduction/combined-release-process.mdx), you can run this action multiple times passing different commands (see the `command` parameter). Just make sure you enable the [state file](../state-reference/index.md) (using the [`stateFile`](../configuration-reference/global-options.mdx#state-file) parameter) and the resume flag (using the [`resume`](../configuration-reference/global-options.mdx#resume) parameter).

```yaml
jobs:
  job1:
    name: My job
    runs-on: ubuntu-latest
    steps:
    - name: Git checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
    - name: Run nyx Infer
      uses: mooltiverse/nyx@main
      with:
        command: infer
        // highlight-start
        resume: true
        stateFile: .nyx-state.json
        // highlight-end
    # Run other tasks here....
    - name: Run nyx Publish
      uses: mooltiverse/nyx@main
      with:
        command: publish
        // highlight-start
        resume: true
        stateFile: .nyx-state.json
        // highlight-end
```

In case you run Nyx in separate jobs (instead of just separate steps within the same job), you may also wish to bring the state file ahead along with the pipeline progress so you can use the [cache action](https://github.com/actions/cache), like in this example:

```yaml
jobs:
  job1:
    name: My job 1
    runs-on: ubuntu-latest
    steps:
    - name: Git checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
    // highlight-start
    - name: Set up the cache to store and retrieve the Nyx state
      uses: actions/cache@v3
      with:
        path: |
          .nyx-state.json
        key: ${{ github.run_id }}-nyx-state
        restore-keys: ${{ github.run_id }}-nyx-state
    // highlight-end
    - name: Run nyx Infer
      uses: mooltiverse/nyx@main
      with:
        command: infer
        resume: true
        stateFile: .nyx-state.json

  job2:
    name: My job 2
    needs: job1
    runs-on: ubuntu-latest
    steps:
    - name: Git checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
    // highlight-start
    - name: Set up the cache to store and retrieve the Nyx state
      uses: actions/cache@v3
      with:
        path: |
          .nyx-state.json
        key: ${{ github.run_id }}-nyx-state
        restore-keys: ${{ github.run_id }}-nyx-state
    // highlight-end
    - name: Run nyx Publish
      uses: mooltiverse/nyx@main
      with:
        command: publish
        resume: true
        stateFile: .nyx-state.json
```

Using separate jobs may also come very useful when using [matrix builds](https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs).
