/* Add support to inject the ExecOperations object in order to run exec commands.
 * See: https://docs.gradle.org/current/userguide/service_injection.html#execoperations
 */
import org.gradle.process.ExecOperations
import javax.inject.Inject
interface InjectedExec {
  @Inject ExecOperations getExecOps()
}

/*------------------------------------------------------------------------------
  Plugins DSL block
  https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block
------------------------------------------------------------------------------*/
plugins {
}

/*------------------------------------------------------------------------------
  Local sub-project properties
------------------------------------------------------------------------------*/
description = 'Documentation microsites'

/*------------------------------------------------------------------------------
  This is the configuration for all sub-projects, but not this project
------------------------------------------------------------------------------*/
subprojects {
  /*----------------------------------------------------------------------------
    Configurations and Dependencies
  ----------------------------------------------------------------------------*/
  // For more on Configurations, Dependencies and Artifacts see:
  // - https://docs.gradle.org/current/userguide/declaring_dependencies_adv.html
  // - https://docs.gradle.org/current/userguide/cross_project_publications.html
  configurations {
    // Here we define the configurations to:
    // - define dependencies to other projects so this project can use their
    //   artifacts
    // - expose artifacts produced by this project that can be used by others as
    //  dependencies
    // Configurations can extend other configurations from within the same
    // project by means of 'extendsFrom'.
    // To add artifacts to configurations use the 'artifacts' section.
    documentation {
      // The 'documentation' configuration depends on the documentation
      // generated by other projects to aggregate all documentations into
      // one local configuration used to import them to the site.
      canBeConsumed = false
      canBeResolved = true
    }
  }

  dependencies {
    // Here we define the static dependencies on other projects' configurations.

    // For all projects listed in the 'importDocumentationFrom' property add a
    // dependency to their 'documentation' configuration to the local
    // 'documentation' configuration.
    if (project.hasProperty("importDocumentationFrom") && !project.getProperty("importDocumentationFrom").isBlank()) {
      project.getProperty("importDocumentationFrom").split(',').each { p -> 
        documentation (project(path: p, configuration: 'documentation'))
      }
    }
  }

  /*----------------------------------------------------------------------------
    Additional properties
  ----------------------------------------------------------------------------*/
  // The directory when dependencies from other projects are stored
  ext.dependenciesDir = new File(buildDir, 'dependencies')

  /*----------------------------------------------------------------------------
    Additional tasks
  ----------------------------------------------------------------------------*/
  task importDocumentationDependencies(group: 'build setup', description: 'Imports the documentation generated by other projects into the local site') {
    // Task dependencies
    dependsOn configurations.documentation

    // The directory where dependencies are stored
    def outputDir = new File(dependenciesDir, 'api/documentation')

    // Declare inputs and outputs of this task
    inputs.files(configurations.documentation.getIncoming().getFiles())
    outputs.dir(outputDir)
    outputs.dir("${projectDir}/docs")
    outputs.dir("${projectDir}/pages")

    doLast {
      logger.quiet("Importing the documentation")
      configurations.documentation.getIncoming().getFiles().each { f -> 
      logger.debug("Extracting the documentation from ${f.name} to ${outputDir.absolutePath}")
        copy {
          from tarTree(f)
          into(outputDir)
        }
      }

      // Now use a copySpec to distribute the imported documentation to the microsite
      if (project.hasProperty("importDocumentationCopySpec") && !project.getProperty("importDocumentationCopySpec").isBlank()) {
        def json = new groovy.json.JsonSlurper().parseText(project.getProperty("importDocumentationCopySpec"))
        try {
          if (json.containsKey('rules') && json.rules.size() > 0) {
            // Copy the union of all documentations from the temporary directory
            // to the local directory.
            logger.debug("Copying the documentation ${outputDir.absolutePath} to the site directory")

            // If we don't add any nested copySpec rule the 'copy' task just copies
            // everything, and that's what we don't want, otherwise, when there are
            // rules, they just copy twice.
            copy {
              into(projectDir)
              json.rules.each { rule ->
                logger.debug("Setting rule: ${rule}")
                if (rule.containsKey('from') && rule.containsKey('into')) {
                  from(new File(outputDir, rule.from)) {
                    into(rule.into)
                    if (rule.containsKey('include')) {
                      rule.include.each { includeOption -> 
                        include(includeOption)
                      }
                    }
                    if (rule.containsKey('exclude')) {
                      rule.exclude.each { excludeOption -> 
                        exclude(excludeOption)
                      }
                    }
                    if (rule.containsKey('rename')) {
                      rule.rename.each { renameOption -> 
                        rename(renameOption.from, renameOption.to)
                      }
                    }
                  }
                } else {
                  throw new GradleException("Rule ${rule} is malformed. The 'from' and 'into' attributes are required")
                }
              }
            }
          } else {
            logger.warn("The 'importDocumentationCopySpec' does not define any rules. The documentation can't be imported.")
          }
        } catch (Exception e) {
          logger.error(e.message)
          throw new GradleException("The 'importDocumentationCopySpec' JSON property is missing or malformed.", e)
        }
      }
    }
  }

  // This is a lifecycle task that will depend on other tasks.
  task importDependencies(group: 'build setup', description: 'Imports the the dependencies from other projects') {
    dependsOn importDocumentationDependencies
  }

  task docusaurusInstall(group: 'build setup', description: 'Installs Docusaurus') {
    // Declare inputs and outputs of this task
    // Run this task if there's any change in Docusaurus' configuration
    inputs.files('docusaurus.config.ts')
    // Output of this task is the '.docusaurus' and 'node_modules' subdirectory
    outputs.dir('.docusaurus')
    outputs.dir('node_modules')

    // Inject the ExecOperations service to run exec commands (see imports on top of the file)
    def injectedExecOps = project.objects.newInstance(InjectedExec)
    doLast {
      logger.quiet("Installing Docusaurus")
      injectedExecOps.execOps.exec {
        workingDir projectDir
        commandLine 'npm', 'install'
      }
    }
  }

  task docusaurusUpgrade(group: 'build setup', description: 'Upgrades Docusaurus and the libraries used by the microsite') {
    dependsOn docusaurusInstall
    // Declare inputs and outputs of this task
    // Run this task if there's any change in Docusaurus' configuration
    inputs.files('docusaurus.config.ts')

    // Inject the ExecOperations service to run exec commands (see imports on top of the file)
    def injectedExecOps = project.objects.newInstance(InjectedExec)
    doLast {
      logger.quiet("Checking for packages requiring upgrade")
      injectedExecOps.execOps.exec {
        workingDir projectDir
        commandLine 'npm', 'outdated'
      }

      logger.quiet("Upgrading packages")
      injectedExecOps.execOps.exec {
        workingDir projectDir
        commandLine 'npx', 'npm-check-updates', '-u' 
      }
      injectedExecOps.execOps.exec {
        workingDir projectDir
        commandLine 'npm', 'install' 
      }
      injectedExecOps.execOps.exec {
        workingDir projectDir
        commandLine 'npm', 'audit', 'fix'
      }

      logger.quiet("Cleaning up the cache")
      injectedExecOps.execOps.exec {
        workingDir projectDir
        commandLine 'npm', 'run', 'clear' 
      }
    }
  }

  task docusaurusBuild(group: 'build', description: 'Renders the documentation site with Docusaurus') {
    dependsOn docusaurusInstall
    dependsOn importDocumentationDependencies

    // Declare inputs and outputs of this task
    // Run this task if there's any newer file among project sources
    // excluding Docusaurus' install files and the rendered outputs.
    inputs.files(fileTree(dir: projectDir, excludes: [buildDir.name, '.docusaurus', 'node_modules']))
    inputs.files(importDocumentationDependencies.outputs.files)
    // Output of this task is the 'build' subdirectory
    outputs.dir(buildDir)

    // Inject the ExecOperations service to run exec commands (see imports on top of the file)
    def injectedExecOps = project.objects.newInstance(InjectedExec)
    doLast {
      logger.quiet("Building the Docusaurus site")
      injectedExecOps.execOps.exec {
        workingDir projectDir
        commandLine 'npm', 'run', 'build'
      }
    }
  }

  // This is just a lifecycle task
  task publish(group: 'publishing', description: 'Publishes Docs artifacts produced by this project to remote destinations') {
    // Publication is performed outside of these build scripts and it's done by
    // the target platform pulling contents from the Git repository.
  }

  task docusaurusClean(group: 'build', description: 'Deletes the local documentation site') {
  }

  task deepClean(group: 'build', description: 'Clean the reproducible and reusable artifacts including caches, dependencies etc') {
    dependsOn clean

    doLast {
      logger.quiet("Deleting the Docusaurus cache")
      delete '.docusaurus'
      delete 'node_modules'
    }
  }

  /*----------------------------------------------------------------------------
    Additional task dependencies
    ----------------------------------------------------------------------------*/
  tasks.assemble.dependsOn docusaurusBuild
  tasks.clean.dependsOn docusaurusClean

  /*----------------------------------------------------------------------------
    Artifacts published by this project
  ----------------------------------------------------------------------------*/
  // For more on Configurations, Dependencies and Artifacts see:
  // - https://docs.gradle.org/current/userguide/declaring_dependencies_adv.html
  // - https://docs.gradle.org/current/userguide/cross_project_publications.html
  artifacts {
    // Here we associate artifacts produced by this project to the
    // configurations so that they can be consumed by other projects.
  }
}

/*------------------------------------------------------------------------------
  Additional tasks
  ------------------------------------------------------------------------------*/
// This is just a lifecycle task
task publish(group: 'publishing', description: 'Publishes artifacts produced by this project') {
  dependsOn subprojects*.publish
}

task deepClean(group: 'build', description: 'Clean the reproducible and reusable artifacts including caches, dependencies etc') {
  dependsOn subprojects*.clean
}

/*------------------------------------------------------------------------------
  Additional task dependencies
  ------------------------------------------------------------------------------*/
tasks.assemble.dependsOn subprojects*.assemble
tasks.build.dependsOn subprojects*.build
tasks.clean.dependsOn subprojects*.clean
