---
title: Build process, tools and environments
layout: single
toc: true
permalink: /best-practice/build-process-tools-and-environments/
---

## Build scripts

Whether you're building locally or on a CI/CD environment you should try to keep your build process **consistent**, **portable** and **efficient**.

Chances are that when using a CI/CD platform you also need to build locally before you commit so your scripts need to be **portable** to run **idempotently** on both environments to ensure that the process itself is defined and tested just like any other artifact in your project. It also means that the script doesn't make strong assumptions on one environment or the other.

An **efficient** build process avoids useless repetitions and usually takes advantage of **incremental** builds and parallel execution to shorten the time needed to complete.

A **consistent** process doesn't need to repeat the same tasks in order to grant that the output of one task never changes provided the same input. Single tasks have their dependencies modelled in order to balance granularity and reuse of already available artifacts but under no circumstance the same task should be repeated to produce the same artifacts. If you find yourself in duplicating code in the build scripts you likely need to refactor task dependencies or parametrize the script.

To achieve all this you should author your primary scripts using a build tool of your choice (i.e. Gradle, Maven etc) and have the CI/CD platform invoke those scripts, instead duplicating the logic. In other words you treat your primary build scripts as the *single source of truth* for your build process while CI/CD platforms may have additional scripts to bridge the gap between the hosting platform and the primary script, when necessary.

How does all this relate to Nyx and the release process?

In the first place the release process (and the tools it uses) must not break any of the above principles. In particular the release management tool must not break the **consistency** principle (as many of the tools out there do). Since the *release* task should be [transactional]({{ site.baseurl }}/in-depth/design-principles/#transactional-release-process), most release management tools encapsulate all of their logic in one single *atomic* task and, for example, do not allow you to know the version number before the *release* task, which usually runs in the end and only in some circumstances. The issue here is that:
* all of the previous tasks (like *build*, *test*, *publish* etc) need to generate their own *fictional* version number to build and package artifacts but that's not the same number that the *release* task will use in the end so, when releasing, the generation of artifacts must be executed again to use the right version. To narrow the negative impact of repeating tasks you do not re-run tests or, if you do, you lose all of the **efficiency** as you basically end up by repeating the entire process by dependencies of the *release* task
* in those environments or configurations where the *release* task must not run (i.e. in *feature branches*) you can't use the version number generated by the build tool so your build process is not **portable** and really reliable

Nyx avoids the above issues and saves [**transactionality**]({{ site.baseurl }}/in-depth/design-principles/#transactional-release-process) as its [internal workflow]({{ site.baseurl }}/in-depth/design-principles/#internal-workflow) is split in two phases: the first one (**inference**) doesn't apply any changes to the project but only configures it, also inferring the version number, while the second one (**publication**), usually executed in the last part of the build process, actually performs the release. In case the *release* task doesn't run (i.e. because the process breaks because of failed tests or the current configuration or branch doesn't require to release), Nyx just ensures that the version that was generated is still **consistent** so an **incremental** build can start from where it left.

## Task Order

In a standard build script you probably have, among others the `publish` and the `release` tasks. You shouldn't collapse them into one just because they have different objectives.

The `publish` task uploads artifacts and makes them available to your audience and this may happen even for those pipelines not ending with a real release. The `release` task, on the other hand, performs some final activities to *seal* the release and make it official. The `release` task should not be used to *publish* anything with the only exception of the release itself, along with changelog and release notes.

As already [mentioned](#build-scripts), `publish` and `release` are condensed into one to work around the limitation of some release management not issuing the release version until the `release` execution but when using Nyx [the version number is issued in the early stages]({{ site.baseurl }}/in-depth/design-principles/#internal-workflow) so you don't need to deal with this limitation.

In summary, you should keep the `publish` and `release` steps separate and run the `release` step after all others have completed successfully. Nyx takes action in the `release` step only, while `publishing` is out of Nyx scope.

Whether to run the *publish* before or after the *release* step is often controversial. We believe that *release* should be executed as the very final step because while you can publish additional releases (in case you can't *roll back* a publication by deleting the artifacts), releasing multiple times might be very misleading for the project consumers. From a semantic standpoint the *release* is also a sort of *stamp* that, once applied, grants that the version being delivered has passed all of the required steps, including publications.
{: .notice--info}

## Environment Segregation

The *release* task should be considered critical as it affects the audience and consumers of your project. Issuing wrong releases or not granting a consistent release process has serious impact on the reputation of your project and that's why you should release carefully.

Release should only be issued from a centralized CI/CD environment with limited access for configuration changes and only after all the tests have been performed. Releases should never be issued from local developer environments and should never overwrite an old release once it has been published.

In order to enforce this principle just make sure that the credentials needed by the release process are kept secret and only available on the CI/CD environment, usually as environment variables. Never share those credentials with anyone nor store them in any file within the repository.
