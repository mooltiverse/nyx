# This workflow takes care of building, testing and publishing the project and
# its artifacts and it uses the 'reusable' workflows.
#
# The whole process is split into jobs, each running on a different node.
# Jobs are executed conditionally, only when required, in order to avoid wasting
# build time on useless jobs.
# Job dependencies also make longer and expensive tasks depend on the success
# of previous, less expensive tasks. If upstream tasks fail, their dependencies
# are not executed.
#
# Moreover, in order to avoid repeating tasks and start one job from where
# previous ones have finished, intermediate artifacts are handed over from one
# job to another by means of caches. Caches have a few caveats though, like
# being read-only. This means that instead of updating an existing cache, one
# needs to create a new one starting from the previous, so that caches are
# somehow 'chained' together, with one link for each job.
#
# This way of modelling the workflow requires extra engineering but allows for
# fine grained control over the pipeline as a whole. It also introduces some
# overhead, but that comes with the benefit of controlling the workflow stage
# by stage. On the other hand, most of this extra effort is solved using our
# custom reusable actions.
#
# Gradle is used under the hood by reusable workflows and composite actions so
# that we use the same build scripts that developers also use locally on their
# workstations. This improves portability and consistency.

name: Main

on:
  workflow_dispatch:
  push:

# Avoid running multiple pipelines concurrently to avoid overlapping releases
# and tags.
# This is required because the current version is determined at the beginning
# of the workflow using Nyx so if multiple workflows run at the same time they
# may receive the same version and try to create overlapping tags and releases.
# With this concurrency settings jobs are on hold until previous pipelines
# have completed.
concurrency:
  group: project
  cancel-in-progress: false

#env:
  # We can't use the 'env' context for reusable workflows, so we need to hardcode
  # the values in each reusable workflow instance.
  #GO_VERSION: 1.22.4
  #JDK_VERSION: 20

jobs:
  #############################################################################
  # Lifecycle and Waypoint Jobs
  #############################################################################
  initialize:
    name: Initialize
    uses: mooltiverse/nyx/.github/workflows/initialize.yml@main
  
  build:
    name: Waypoint
    needs:
    - initialize
    - go-build
    uses: mooltiverse/nyx/.github/workflows/build.yml@main
  
  test:
    name: Waypoint
    needs:
    - initialize
    - build
    uses: mooltiverse/nyx/.github/workflows/test.yml@main

  release:
    name: Release
    needs:
    - initialize
    - test
    - go-publish
    if: needs.initialize.outputs.release == 'true'
    uses: mooltiverse/nyx/.github/workflows/release.yml@main
    with:
      verbosity: info
      install-jdk: true
      install-jdk-version: 20
      # Restore the cache from the previous job to 'chain' caches
      nyx-cache-name-restore-suffix: ${{ needs.initialize.outputs.nyx-cache-name-suffix }}
      go-cache-name-restore-suffix: ${{ needs.go-publish.outputs.go-cache-name-suffix }}

  #############################################################################
  # Go Jobs
  #############################################################################

  go-build:
    name: Go Build
    needs:
    - initialize
    if: needs.initialize.outputs.goChanged == 'true' || needs.initialize.outputs.dockerChanged == 'true' || needs.initialize.outputs.release == 'true'
    uses: mooltiverse/nyx/.github/workflows/go-build.yml@main
    with:
      verbosity: info
      install-go: true
      install-go-version: 1.22.4
      install-jdk: true
      install-jdk-version: 20
      # Restore the cache from the previous job to 'chain' caches
      nyx-cache-name-restore-suffix: ${{ needs.initialize.outputs.nyx-cache-name-suffix }}

  go-publish:
    name: Go Publish
    needs:
    - initialize
    - test
    - go-build
    if: needs.initialize.outputs.release == 'true'
    uses: mooltiverse/nyx/.github/workflows/go-publish.yml@main
    with:
      verbosity: info
      install-go: true
      install-go-version: 1.22.4
      install-jdk: true
      install-jdk-version: 20
      # Restore the cache from the previous job to 'chain' caches
      nyx-cache-name-restore-suffix: ${{ needs.initialize.outputs.nyx-cache-name-suffix }}
      gradle-cache-name-restore-suffix: ${{ needs.go-build.outputs.gradle-cache-name-suffix }}
      go-cache-name-restore-suffix: ${{ needs.go-build.outputs.go-cache-name-suffix }}