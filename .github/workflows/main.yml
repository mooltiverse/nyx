# This workflow takes care of building, testing and publishing the project and
# its artifacts and it uses the 'reusable' workflows.
#
# The whole process is split into jobs, each running on a different node.
# Jobs are executed conditionally, only when required, in order to avoid wasting
# build time on useless jobs.
# Job dependencies also make longer and expensive tasks depend on the success
# of previous, less expensive tasks. If upstream tasks fail, their dependencies
# are not executed.
#
# Moreover, in order to avoid repeating tasks and start one job from where
# previous ones have finished, intermediate artifacts are handed over from one
# job to another by means of caches. Caches have a few caveats though, like
# being read-only. This means that instead of updating an existing cache, one
# needs to create a new one starting from the previous, so that caches are
# somehow 'chained' together, with one link for each job.
#
# This way of modelling the workflow requires extra engineering but allows for
# fine grained control over the pipeline as a whole. It also introduces some
# overhead, but that comes with the benefit of controlling the workflow stage
# by stage. On the other hand, most of this extra effort is solved using our
# custom reusable actions.
#
# Gradle is used under the hood by reusable workflows and composite actions so
# that we use the same build scripts that developers also use locally on their
# workstations. This improves portability and consistency.

name: Main

on:
  workflow_dispatch:
  push:

# Avoid running multiple pipelines concurrently to avoid overlapping releases
# and tags.
# This is required because the current version is determined at the beginning
# of the workflow using Nyx so if multiple workflows run at the same time they
# may receive the same version and try to create overlapping tags and releases.
# With this concurrency settings jobs are on hold until previous pipelines
# have completed.
concurrency:
  group: project
  cancel-in-progress: false

#env:
  # We can't use the 'env' context for reusable workflows, so we need to hardcode
  # the values in each reusable workflow instance.
  #GO_VERSION: 1.22.4
  #JDK_VERSION: 20

jobs:
  #############################################################################
  # Lifecycle and Waypoint Jobs
  #############################################################################
  initialize:
    name: Initialize
    uses: mooltiverse/nyx/.github/workflows/initialize.yml@main
  
  build:
    name: Waypoint
    needs:
    - initialize
    - java-build
    uses: mooltiverse/nyx/.github/workflows/build.yml@main
  
  release:
    name: Release
    needs:
    - initialize
    - java-publish
    if: needs.initialize.outputs.release == 'true'
    uses: mooltiverse/nyx/.github/workflows/release.yml@main
    with:
      verbosity: info
      install-jdk: true
      install-jdk-version: 20
      # Restore the cache from the previous job to 'chain' caches
      nyx-cache-name-restore-suffix: ${{ needs.initialize.outputs.nyx-cache-name-suffix }}
      java-cache-name-restore-suffix: ${{ needs.java-publish.outputs.java-cache-name-suffix }}
      go-cache-name-restore-suffix: ${{ needs.go-publish.outputs.go-cache-name-suffix }}
      docker-cache-name-restore-suffix: ${{ needs.docker-publish.outputs.docker-cache-name-suffix }}

  #############################################################################
  # Java Jobs
  #############################################################################

  java-build:
    name: Java Build
    needs:
    - initialize
    if: needs.initialize.outputs.javaChanged == 'true' || needs.initialize.outputs.release == 'true'
    uses: mooltiverse/nyx/.github/workflows/java-build.yml@main
    with:
      verbosity: info
      install-jdk: true
      install-jdk-version: 20
      # Restore the cache from the previous job to 'chain' caches
      nyx-cache-name-restore-suffix: ${{ needs.initialize.outputs.nyx-cache-name-suffix }}

  java-publish:
    name: Java Publish
    needs:
    - initialize
    - java-build
    if: needs.initialize.outputs.release == 'true'
    uses: mooltiverse/nyx/.github/workflows/java-publish.yml@main
    with:
      verbosity: info
      install-jdk: true
      install-jdk-version: 20
      # Restore the cache from the previous job to 'chain' caches
      nyx-cache-name-restore-suffix: ${{ needs.initialize.outputs.nyx-cache-name-suffix }}
      gradle-cache-name-restore-suffix: ${{ needs.java-build.outputs.gradle-cache-name-suffix }}
      java-cache-name-restore-suffix: ${{ needs.java-build.outputs.java-cache-name-suffix }}
      gradle-tasks: src:java:publish src:java:gradle:publish
    secrets:
      # Pass extra properties used by the Gradle scripts to run tests.
      # See the top level
      #   https://github.com/mooltiverse/nyx/blob/main/CONTRIBUTING.md#contributing-code
      # file for details about passing these values when testing locally.
      # Also see:
      # - https://docs.gradle.org/current/userguide/build_environment.html#setting_a_project_property
      gradle-secret-arguments: >-
        -Dorg.gradle.project.gitHubUser=GITHUB
        -Dorg.gradle.project.gitHubToken=${{ secrets.GITHUB_TOKEN }}
        -Dorg.gradle.project.signingKeyBase64="${{ secrets.GPG_PRIVATE_KEY_BASE64 }}"
        -Dorg.gradle.project.signingPassword="${{ secrets.GPG_PASSPHRASE }}"
        -Dorg.gradle.project.gradlePublishKey="${{ secrets.GRADLE_PLUGIN_PUBLISH_KEY }}"
        -Dorg.gradle.project.gradlePublishSecret="${{ secrets.GRADLE_PLUGIN_PUBLISH_SECRET }}"
